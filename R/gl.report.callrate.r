#' Report summary of Call Rate for loci or individuals
#'
#' SNP datasets generated by DArT have missing values primarily arising from failure to call a SNP because of a mutation
#' at one or both of the the restriction enzyme recognition sites. This script reports the number of missing values for each
#' of several percentiles. The script gl.filter.callrate() will filter out the loci with call rates below a specified threshold.
#'
#' @param x -- name of the genlight or genind object containing the SNP data [required]
#' @param method specify the type of report by locus (method="loc") or individual (method="ind") [default method="loc"]
#' @param plot specify if a histogram of call rate is to be produced [default TRUE]
#' @param v -- verbosity: 0, silent or fatal errors; 1, begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default 2]
#' @return Tabulation of CallRate against Threshold
#' @export
#' @author Arthur Georges (Post to \url{https://groups.google.com/d/forum/dartr})
#' @examples
#' gl.report.callrate(testset.gl)


gl.report.callrate <- function(x, method="loc", plot=TRUE, v=2) {
  
# ERROR CHECKING
  
  if(class(x)!="genlight") {
    cat("Fatal Error: genlight object required for gl.report.callrate!\n"); stop()
  }
  if (method != "ind" & method != "loc") {
    cat("    Warning: method must be either \"loc\" or \"ind\", set to \"loc\" \n")
    method <- "loc"
  }
  if (v < 0 | v > 5){
    cat("    Warning: verbosity must be an integer between 0 [silent] and 5 [full report], set to 2\n")
    v <- 2
  }
  
# FLAG SCRIPT START
  
  if (v >= 1) {
    cat("Starting gl.report.callrate: Reporting distribution of Call Rate\n")
  }
  if (v >= 4){cat("Note: Missing values most commonly arise from restriction site mutation.\n\n")}
  

# RECALCULATE THE CALL RATE, BRING IT UP TO DATE IN CASE gl.recalc.metrics HAS NOT BEEN RUN
  
    x <- dartR:::utils.recalc.callrate(x, v=v)

# FOR METHOD BASED ON LOCUS    
  
  if(method == "loc") {
    
  # Plot a histogram of Call Rate
    par(mfrow = c(2, 1),pty="m")
    
    if (plot) {
      hist(x@other$loc.metrics$CallRate, 
         main="Histogram Call Rate by Locus", 
         xlab="Call Rate", 
         border="blue", 
         col="red",
         xlim=c(min(x@other$loc.metrics$CallRate),1),
         breaks=100
      )
      glPlot(x)
    }  

  # Print out some statistics
    
    cat("No. of loci =", nLoc(x), "\n")
    cat("No. of individuals =", nInd(x), "\n")
    cat("  Miniumum Call Rate: ",round(min(x@other$loc.metrics$CallRate),2),"\n")
    cat("  Maximum Call Rate: ",round(max(x@other$loc.metrics$CallRate),2),"\n")
    cat("  Average Call Rate: ",round(mean(x@other$loc.metrics$CallRate),3),"\n")
    cat("  Missing Rate Overall: ",round(sum(is.na(as.matrix(x)))/(nLoc(x)*nInd(x)),2),"\n\n")

  # Determine the loss of loci for a given filter cut-off
    retained <- array(NA,21)
    pc.retained <- array(NA,21)
    filtered <- array(NA,21)
    pc.filtered <- array(NA,21)
    percentile <- array(NA,21)
    crate <- x@other$loc.metrics$CallRate
    for (index in 1:21) {
      i <- (index-1)*5
      percentile[index] <- i/100
      retained[index] <- length(crate[crate>=percentile[index]])
      pc.retained[index] <- round(retained[index]*100/nLoc(x),1)
      filtered[index] <- nLoc(x) - retained[index]
      pc.filtered[index] <- 100 - pc.retained[index]
    }
    df <- cbind(percentile,retained,pc.retained,filtered,pc.filtered)
    df <- data.frame(df)
    colnames(df) <- c("Threshold", "Retained", "Percent", "Filtered", "Percent")
    df <- df[order(-df$Threshold),]
    rownames(df) <- NULL
    print(df)
  }
  
# FOR METHOD BASED ON INDIVIDUAL   
    
  if(method == "ind") {
    
    # Calculate the call rate by individual
    ind.call.rate <- 1 - rowSums(is.na(as.matrix(x)))/nLoc(x)
    
    # Plot a histogram of Call Rate
    
    if (plot) {
      hist(ind.call.rate, 
        main="Histogram Call Rate by Individual", 
        xlab="Call Rate", 
        border="blue", 
        col="red",
        xlim=c(min(ind.call.rate),1),
        breaks=100
      )
      glPlot(x)
    }  
    
    cat("No. of loci =", nLoc(x), "\n")
    cat("No. of individuals =", nInd(x), "\n")
    cat("  Miniumum Call Rate: ",round(min(ind.call.rate),2),"\n")
    cat("  Maximum Call Rate: ",round(max(ind.call.rate),2),"\n")
    cat("  Average Call Rate: ",round(mean(ind.call.rate),3),"\n")
    cat("  Missing Rate Overall: ",round(sum(is.na(as.matrix(x)))/(nLoc(x)*nInd(x)),2),"\n\n")

    # Determine the loss of individuals for a given filter cut-off
    retained <- array(NA,21)
    pc.retained <- array(NA,21)
    filtered <- array(NA,21)
    pc.filtered <- array(NA,21)
    percentile <- array(NA,21)
    crate <- ind.call.rate
    for (index in 1:21) {
      i <- (index-1)*5
      percentile[index] <- i/100
      retained[index] <- length(crate[crate>=percentile[index]])
      pc.retained[index] <- round(retained[index]*100/nInd(x),1)
      filtered[index] <- nInd(x) - retained[index]
      pc.filtered[index] <- 100 - pc.retained[index]
    }
    df <- cbind(percentile,retained,pc.retained,filtered,pc.filtered)
    df <- data.frame(df)
    colnames(df) <- c("Threshold", "Retained", "Percent", "Filtered", "Percent")
    df <- df[order(-df$Threshold),]
    rownames(df) <- NULL
    print(df)
  }

# FLAG SCRIPT END
  if (v >= 1) {
    cat("gl.report.callrate Completed\n")
  }

  return(df)
  
}
