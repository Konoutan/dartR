#' Concatenates DArT trimmed sequences after removing heterozygous loci by random allele assignment
#'
#' This script randomly allocates haplotypes in a DArT genlight object in preparation for analyses
#' that expect only a single character state for each individual at each locus. For example, many 
#' phylogenetic analyses have difficulty accommodating heterozygosity. Under this approach, such an
#' analysis becomes one of determining the phylogeny of composite haplotypes. 
#' 
#' The haplotypes are generated by randomly assigning one or the other SNP variant to the individual 
#' in instances of homozygosity, then concatenating the haplotypes across loci to generate 
#' a single haplotype to be used in the analysis. If repeated runs yield the same topology and 
#' roughly the same branch lengths, then the resultant haplotype tree can be considered to also 
#' be the species tree.
#' 
#' The script writes out the composite haplotypes for each individual as a fastA file. Requires
#' trimmed sequences to be among the locus metrics.
#' 
#' @param gl -- name of the DArT genlight object [required]
#' @param outfile -- name of the output file (fasta format) [output.fasta]
#' @return A new gl object with all loci rendered homozygous
#' @export
#' @author Arthur Georges (glbugs@@aerg.canberra.edu.au)
#' @examples
#' \dontrun{
#' gl2fasta.nohets(gl, outfile="test.fasta")
#' }

#install.packages("stringdist")
#library(stringr)
#library(stringdist)

gl2fasta.nohets <- function(gl, outfile="output.fasta") {
  
  if(class(gl) == "genlight") {
    cat("Analysing a genlight object\n")
  } else {
    cat("Fatal Error: Specify a genlight object\n")
    stop()
  }
  if(length(gl@other$loc.metrics$TrimmedSequence) == 0) {
    cat("Fatal Error: Data must include Trimmed Sequences\n"); stop()
  }
  
# Randomly allocate heterozygotes (1) to homozygote state (0 or 2)
  matrix <- as.matrix(gl)
  cat("Randomly allocating heterozygotes (1) to homozygote state (0 or 2)\n")
  pb <- txtProgressBar(min=0, max=1, style=3, initial=0, label="Working ....")
  getTxtProgressBar(pb)
  r <- nrow(matrix)
  c <- ncol(matrix)
  for (i in 1:r) {
    for (j in 1:c) {
      if (matrix[i,j] == 1 && !is.na(matrix[i,j])) {
        # Score it 0 or 2
        matrix[i,j] <- (sample(1:2, 1)-1)*2
      }
    }
    setTxtProgressBar(pb, i/r)
  }
  
# Check that the sequences are all the same length
  
  mx <- max(str_length(gl@other$loc.metrics$AlleleSequence))
  mn <- min(str_length(gl@other$loc.metrics$AlleleSequence))
  if (mn == mx) {
    cat(paste("\nAllelic sequences (incl. adaptors) are all the same length:", mx),"\n")
  } else {
    cat("Allele sequences not all the same length, padding with NNNNs\n")
    gl@other$loc.metrics$AlleleSequence <- str_pad(gl@other$loc.metrics$AlleleSequence, mx, side = c("right"), pad = "N")
  }
  
# Prepare the output fastA file
  cat("Generating haplotypes ... This may take some time\n")

  sink(outfile)

# For each individual, and for each locus, generate the relevant haplotype 
  seq <- rep(" ", c)
  for (i in 1:r) {
    for (j in 1:c) {
      # Reassign some variables
      fragment <- as.character(gl@other$loc.metrics$AlleleSequence[j])
      trimmed <- as.character(gl@other$loc.metrics$TrimmedSequence[j])
      snp <- as.character(gl@other$loc.metrics$SNP[j])
      snpos <- gl@other$loc.metrics$SnpPosition[j]
      
      # If the score is for the reference SNP
      if (matrix[i,j] == 0 && !is.na(matrix[i,j])) {
        seq[j] <- trimmed

      # Else if the score is for the alternate SNP  
      } else if (matrix[i,j] == 2 && !is.na(matrix[i,j])) {
        # Split the fragment into a beginning sequence, the SNP and an end sequences
        start <- str_sub(fragment, end=snpos)
        snpbase <- str_sub(fragment, start=(snpos+1), end=(snpos+1))
        end <- str_sub(fragment, start=snpos+2)
        # Extract the SNP transition bases (e.g. A and T)
        state.change <- str_split_fixed(snp,":",2)
        state1 <- str_sub(state.change[2], start=1, end=1)
        state2 <- str_sub(state.change[2], start=3, end=3)
        # Change the SNP state to the alternate
        if (snpbase == state1) {
          snpbase <- state2
        } else {
          snpbase <- state1  
        }
        # Paste back to form the new alternate fragment
        target <- paste0(start,snpbase,end)
        # Remove adaptors and save the trimmed alternate sequence
        #seq[j] <- gl.utils.1(trimmed,target)
        seq[j] <- str_sub(target, start=1, end=nchar(trimmed))
        
      # If the SNP state is missing, assign NNNNs  
      } else if (is.na(matrix[i,j])) {
        seq[j] <- "N"
        seq[j] <- str_pad(seq[j], nchar(trimmed), side = c("right"), pad = "N")
      }
    }
    
    # Join all the trimmed sequence together into one long "composite" haplotype
    result <- paste(seq,sep="",collapse="")
    # Write the results to file in fastA format
    cat(paste0(">", indNames(gl)[i],"|",pop(gl)[i], "\n"))
    cat(result, " \n")
  
  } # Select the next individual and repeat
  
# Close the output fastA file
  
  sink()

return(TRUE)
  
}


