#' PCoA ordination applied to genotypes in a genlight object or to a distance matrix
#'
#' This function takes the data on SNP genotypes for individuals and undertakes a Gower Principal Coordinates Ordination using (a) Euclidean distance calculated from
#' data in the original genlight \{adegenet\} object (entity x attribute matrix) OR (b) drawing upon a distance matrix generated with gl.dist.pop() 
#' or gl.dist.ind(). By providing the function with a distance matrix, technically any distance matrix can be represented in an ordinated space.
#' 
#' The function is essentially a wrapper for pcoa \{ape\} with default settings apart from those specified as parameters in this 
#' function.
#' 
#' There are three major sources of stress in a reduced-reprentation of distances or dissimilarities among entities using PCoA. By far the greatest
#' source comes from the decision to select only the top two or three axes from the ordinated set of axes derived from the PCoA. The representation of
#' the entities such a heavily reduced space will not faithfully represent the distances in the input distance matrix simply because of the loss of information
#' in deeper informative dimensions. For this reason, it is not sensible to be too precious about managing the other two sources of stress in
#' the visual representation.
#' 
#' The second source of stress in a PCoA is the choice of distance metric or dissimilarity measure. While any 
#' distance or dissimilarity matrix can be represented in an ordinated space, the distances between entities can befaithfully represented 
#' in that space (that is, without stress) only if the distances are metric. Furthermore, for distances between entities to be faithfully 
#' represented in a rigid Cartesian space, the distance measure needs to be Euclidean. If this is not the case, 
#' the distances between the entities in the ordinated visualized space will not exactly represent the distances in the input matrix 
#' (stress will be non-zero). This source of stress will be evident as negative eigenvalues in the deeper dimensions. 
#' 
#' A third source of stress arises from having a sparse dataset, one with missing values. If the original data matrix is not fully populated, that is, 
#' if there are missing values, then even a Euclidean distance matrix will not necessarily be 'positive definite'. It follows that some of the eigenvalues 
#' may be negative, even though the distance metric is Euclidean. This issue is exacerbated when the number of loci greatly exceeds the number of individuals, 
#' as is typically the case when working with SNP data. The impact of missing values can be minimized by stringently filtering on Call Rate, albeit with 
#' loss of data. An alternative is given in a paper "Honey, I shrunk the sample covariance matrix" and more recently by Ledoit and Wolf (2018), but their 
#' approach has not been implemented here. 
#' 
#' The good news is that, unless the sum of the negative eigenvalues, arising from a non-Euclidean distance measure or from missing values, approaches those 
#' of the final PCoA axes to be displayed, the distortion is probably of no practical consequence and certainly not comparable to the stress arising from
#' selecting only two or three final dimensions out of several informative dimensions for the visual representation.
#' 
#' Two diagnostic plots are produced. The first is a Scree Plot, showing the percentage variation explained by each of the PCoA axes, for those axes that 
#' explain more than the original variables (loci) on average. That is, only informative axes are displayed. The scree plot informs the number of dimensions
#' to be retained in the visual summaries. As a rule of thumb, axes with more than 10% of variation explained should be included.
#' 
#' The second graph shows the distribution of eigenvalues for the remaining uninformative (noise) axes, including those with negative eigenvalues. 
#' Action is required if the negative eigenvalues are dominant, their sum approaching in magnitude the eigenvalues for axes selected for 
#' the final visual solution. That action would involve more stringent filtering on call rate and then repeating the PCoA.
#' 
#' Output is a pcoa object conforming to the object generated by ape:pcoa but with only the following retained.
#'  $values
#'    Eigenvalues	-- All eigenvalues (positive, null, negative).
#'    Relative_eig -- Relative eigenvalues.
#'  $vectors 
#'    Scores (coefficients) for each individual
#' 
#' @references
#' Gower, J. C. (1966) Some distance properties of latent root and vector methods used in multivariate analysis. Biometrika, 53, 325â€“338.
#' Ledoit, O. and Wolf, M. (2018). Analytical Nonlinear Shrinkage of Large-Dimensional Covariance Matrices. University of Zurich, Department of Economics, Working Paper No. 264, Revised version. Available at SSRN: https://ssrn.com/abstract=3047302 or http://dx.doi.org/10.2139/ssrn.3047302 
#'
#' @param x -- name of the genlight object containing the SNP data or a distance matrix of type dist [required]
#' @param nfactors -- number of axes to retain in the output of factor scores.
#' @param verbose -- specify the level of verbosity: 0, silent, fatal errors only; 1, flag function begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default 2]
#' @return An object of class pcoa containing the eigenvalues and factor scores
#' @importFrom ape pcoa
#' @export
#' @author Arthur Georges (Post to \url{https://groups.google.com/d/forum/dartr})
#' @examples
#' pcoa <- gl.pcoa.beta(testset.gl)

# Last amended 11-Sep-19

gl.pcoa.beta <- function(x, nfactors=5, verbose=2) {

# TIDY UP FILE SPECS

  funname <- match.call()[[1]]

# FLAG SCRIPT START

  if (verbose < 0 | verbose > 5){
    cat("  Warning: Parameter 'verbose' must be an integer between 0 [silent] and 5 [full report], set to 2\n")
    verbose <- 2
  }

  if (verbose > 0) {
    cat("Starting",funname,"\n")
  }

# STANDARD ERROR CHECKING
  
  if(class(x)=="genlight"){
    if(verbose >= 2){cat("  Genlight object detected\n")}
  } else if(class(x)=="dist"){
    if(verbose >= 2){cat("  Distance matrix detected\n")}
  } else {
    cat("  Fatal Error: genlight object or distance matrix required!\n"); stop("Execution terminated\n")
  }
  
# DO THE JOB

    if (verbose >=2) {cat("  Performing a PCoA, individuals as entities, SNP loci as attributes\n")}

  # Create the distance matrix if none provided
    if (class(x)=="genlight"){
      pop(x) <- indNames(x)
      D <- gl.dist.pop(x,verbose=verbose)
    } else {
      D <- x
    }
  
  # Calculate the pcoa
    pco <- pcoa(D,rn=labels(D))
    
  # Extract relevant variables
    
    eig.raw <- pco$values$Eigenvalues
  
  # Identify the number of axes with explanatory value greater than the original variables on average
    eig.raw.pos <- eig.raw[eig.raw >= 0] 
    eig.raw.pos.pc <- eig.raw.pos*100/sum(eig.raw.pos)
    eig.top <- eig.raw.pos[eig.raw.pos > mean(eig.raw.pos)]
    eig.top.pc <- round(eig.top*100/sum(eig.raw.pos),1)
    eig.raw.noise <- eig.raw[eig.raw <= mean(eig.raw)]

    if (any(eig.raw < 0)){
      if(verbose >= 2){
        problem <- (-sum(eig.raw[eig.raw<0])/mean(eig.raw[1:3]))*100
          cat("  Warning: Some eigenvalues negative -- sum to",round(problem,2),"% of the mean eigenvalue for PCoA axes 1-3\n")
          cat("    Tolerable negative eigenvalues should sum to much less than the eigenvalues of displayed PCoA axes (say, less than 20%)\n")
          if (problem > 20 & class(x) == 'dist'){cat("    If an non-Euclidean distance was used, perhaps reconsider your choice of distance metric or dissimilarity measure\n")}
          if (problem > 20){cat("    If a genlight object was used (or a distance matrix generated from a genlight object), consider filtering more stringently on Call Rate\n")}
      }  
    }
    
  # Provide a summary  
    if (verbose >=3) {
      cat(paste("  Ordination yielded",length(eig.top),"informative dimensions from",nInd(x)-1,"original dimensions\n"))
      cat(paste("    PCoA Axis 1 explains",round(eig.raw.pos.pc[1],1),"% of the total variance\n"))
      cat(paste("    PCoA Axis 1 and 2 combined explain",round(eig.raw.pos.pc[1]+eig.raw.pos.pc[2],1),"% of the total variance\n"))
      cat(paste("    PCoA Axis 1-3 combined explain",round(eig.raw.pos.pc[1]+eig.raw.pos.pc[2]+eig.raw.pos.pc[3],1),"% of the total variance\n"))
    }

# PLOT DIAGNOSTICS
    
    # Save the prior settings for mfrow, oma, mai and pty, and reassign
    op <- par(mfrow = c(2, 1), oma=c(1,1,1,1), mai=c(0.5,0.5,0.5,0.5),pty="m")
    
    # Set margins for first plot
    par(mai=c(1,1,0.5,0.5))
    
    # Plot Scree plot

    m <- cbind(seq(1:length(eig.top.pc)),eig.top.pc)
    df <- data.frame(m)
    colnames(df) <- c("eigenvalue","percent")
    xlab <- paste("PCoA Axis")
    ylab <- paste("Percentage Contribution")
    plot(df$eigenvalue,df$percent,col='red', main="Informative Axes -- Scree Plot", type="o",xlab=xlab,ylab=ylab)
    abline(h=10,col="blue")

    # Set margins for second plot
    par(mai=c(1,1,0.5,0.5))

      if (any(eig.raw < 0)){
          main <- "Noise Axes -- WArning: some eigenvalues < 0"
      } else {
          main <- "Noise Axes -- all eigenvalues positive"
      }  
      hist(eig.raw.noise, 
           main=main, 
           xlab="Eigenvalue", 
           col="red",
           breaks=100)
      abline(v=0,col="blue",lwd=2)

# FLAG SCRIPT END

  if (verbose > 0) {
    cat("Completed:",funname,"\n")
  }
    
  # Reset the par options    
    par(op)
    
    pco$values <- pco$values[,1:2]
    pco$vectors <- pco$vectors[,1:nfactors]
    
    return(pco)
}

