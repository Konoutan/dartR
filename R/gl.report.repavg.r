#' Report summary of RepAvg, reproducibility averaged over both alleles for each locus in a genlight {adegenet} object
#'
#' SNP datasets generated by DArT have in index, RepAvg, generated by reproducing the data independently for 30% of loci.
#' RepAvg is the proportion of alleles that give a reproducible result, averaged over both alleles for each locus.
#'
#' @param x -- name of the genlight object containing the SNP data [required]
#' @param plot specify if a histogram of call rate is to be produced [default TRUE]
#' @param v -- verbosity: 0, silent or fatal errors; 1, begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default 2]
#' @return -- Tabulation of repAvg against Threshold
#' @export
#' @author Arthur Georges (bugs? Post to \url{https://groups.google.com/d/forum/dartr})
#' @examples
#' gl.report.repavg(testset.gl)


gl.report.repavg <- function(x) {

# ERROR CHECKING
  
  if(class(x)!="genlight") {
    cat("Fatal Error: genlight object required for gl.report.repavg!\n"); stop()
  }

  if (v < 0 | v > 5){
    cat("    Warning: verbosity must be an integer between 0 [silent] and 5 [full report], set to 2\n")
    v <- 2
  }
  if (v >= 5){cat("Note: RepAvg is a DArT statistic reporting repeatability averaged across alleles for each locus. \n\n")}
  
# FLAG SCRIPT START
  if (v >= 1) {
    cat("Starting gl.report.repavg: Reporting distribution of Repeatability (repAvg)\n")
  }
  
  repAvg <- x@other$loc.metrics$RepAvg
  xlimit <- min(repAvg)
  
  cat("No. of loci =", nLoc(x), "\n")
  cat("No. of individuals =", nInd(x), "\n")
  cat("  Miniumum repeatability: ",round(min(repAvg),2),"\n")
  cat("  Maximum repeatability: ",round(max(repAvg),2),"\n")
  cat("  Mean repeatability: ",round(mean(repAvg),3),"\n\n")

  # Determine the loss of loci for a given filter cut-off
  retained <- array(NA,21)
  pc.retained <- array(NA,21)
  filtered <- array(NA,21)
  pc.filtered <- array(NA,21)
  percentile <- array(NA,21)
  for (index in 1:21) {
    i <- (index - 1)/20
    i <- (i - 1)*(1-xlimit) + 1
    percentile[index] <- i
    retained[index] <- length(repAvg[repAvg >= percentile[index]])
    pc.retained[index] <- round(retained[index]*100/nLoc(x),1)
    filtered[index] <- nLoc(x) - retained[index]
    pc.filtered[index] <- 100 - pc.retained[index]
  }
  df <- cbind(percentile,retained,pc.retained,filtered,pc.filtered)
  df <- data.frame(df)
  colnames(df) <- c("Threshold", "Retained", "Percent", "Filtered", "Percent")
  df <- df[order(-df$Threshold),]
  rownames(df) <- NULL
  print(df)
  
  # Plot a histogram of Call Rate
  par(mfrow = c(2, 1),pty="m")
  
  if (plot) {
    hist(repAvg, 
         main="Repeatbility by Locus", 
         xlab="Repeatability", 
         border="blue", 
         col="red",
         xlim=c(min(repAvg),1),
         breaks=100
    )
    glPlot(x)
  }  
  
# FLAG SCRIPT END
  if (v >= 1) {
    cat("gl.report.repavg Completed\n")
  }
  
  return(df)

}


